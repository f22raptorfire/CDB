package wci.backend.compiler;

import static wci.intermediate.symtabimpl.DefinitionImpl.*;
import static wci.intermediate.symtabimpl.SymTabKeyImpl.*;

import java.io.*;
import java.util.ArrayList;

import wci.intermediate.*;
import wci.intermediate.icodeimpl.ICodeImpl;
import wci.intermediate.symtabimpl.DefinitionImpl;
import wci.intermediate.symtabimpl.SymTabKeyImpl;
import wci.backend.*;
import wci.backend.compiler.generators.StatementCodeGenerator;

/**
 * <p>The code generator for a compiler back end.</p>
 *
 * <p>Copyright (c) 2008 by Ronald Mak</p>
 * <p>For instructional purposes only.  No warranties.</p>
 */
public class CodeGenerator extends Backend
{
    private static final int STACK_LIMIT = 16;
        
    protected static ICode iCode;
    protected static int varCount;
    protected static SymTabStack symTabStack;
    protected static PrintWriter objectFile;
    protected static int labelCount = 0;

    public CodeGenerator() {}
    
    public CodeGenerator(CodeGenerator parent) {
    	super();
    }
    
    /**
     * Process the intermediate code and the symbol table generated by the
     * parser to generate machine-language instructions.
     * @param iCode the intermediate code.
     * @param symTabStack the symbol table stack.
     * @param objectFile the object file path for the generated code.
     * @throws Exception if an error occurred.
     */
    public void process(ICode iCode, SymTabStack symTabStack,
                        PrintWriter objectFile)
        throws Exception
    {
    	System.out.println("\n===== BACKEND CODE =====\n");
    	
        this.symTabStack = symTabStack;
        this.iCode = iCode;
        this.objectFile = objectFile;
        this.varCount = 0;

    	printHeader(objectFile);
    	printFields(objectFile);
    	printMethods(objectFile);
    	printInit(objectFile);
    	printMain(objectFile);
    	objectFile.close();
    }
    
    private void printHeader(PrintWriter objectFile) throws FileNotFoundException {
    	SymTabEntry programId = symTabStack.getProgramId();
    	objectFile.append(".class public " + programId.getName() + "\n");
    	objectFile.append(".super java/lang/Object\n");
    	objectFile.append("\n");
    	objectFile.append(".field public static _database Lwci/runtime/CDBC;\n");
    	objectFile.append(".field public static _references [Lwci/runtime/Referencer;\n\n");
    }
    
    private void printMethods(PrintWriter objectFile) throws FileNotFoundException {
    	SymTabEntry programId = symTabStack.getProgramId();
    	SymTab program = (SymTab) programId.getAttribute(SymTabKeyImpl.ROUTINE_SYMTAB);
    	ArrayList<SymTabEntry> entries = program.sortedEntries();
    	for (SymTabEntry entry : entries) {
        	if (entry.getDefinition() == PROCEDURE) {
        		objectFile.append(".method static " + entry.getName() + "(");
        		ArrayList<SymTabEntry> parameters = (ArrayList<SymTabEntry>) entry.getAttribute(ROUTINE_PARMS);
        		
        		if (parameters != null) {
	        		for (SymTabEntry parameter : parameters) {
	        			if (parameter.getDefinition() == DefinitionImpl.REFERENCE)
	        				objectFile.append("Lwci/runtime/Referencer;");
	        			else
	        				objectFile.append(parameter.getTypeSpec().getTypeId());
	        		}
        		}
        		objectFile.append(")V\n");
        		objectFile.append(".limit stack 16\n");
            	objectFile.append(".limit locals 10\n\n");

            	symTabStack.push((SymTab) entry.getAttribute(ROUTINE_SYMTAB));
            	StatementCodeGenerator gen = new StatementCodeGenerator(this);
        		objectFile.append(gen.generate((ICodeNode)((ICodeImpl)entry.getAttribute(ROUTINE_ICODE)).getRoot()).toString());
        		symTabStack.pop();
        		
        		objectFile.append("\treturn\n");
            	objectFile.append("\n");
        		objectFile.append(".end method\n");
            	objectFile.append("\n");
        	}
        }
    }
    
    private void printFields(PrintWriter objectFile) throws FileNotFoundException {
    	SymTabEntry programId = symTabStack.getProgramId();
    	SymTab program = (SymTab) programId.getAttribute(SymTabKeyImpl.ROUTINE_SYMTAB);
    	ArrayList<SymTabEntry> entries = program.sortedEntries();
    	String type;
    	for (SymTabEntry entry : entries) {
    		if (entry.getDefinition() == VARIABLE) {
    			type = entry.getTypeSpec().getTypeId();
    			objectFile.append(".field public static " + entry.getName() + " " + type + "\n");
    		}
    	}
		objectFile.append("\n");
    }
    
    private void printInit(PrintWriter objectFile) throws FileNotFoundException {
		objectFile.append(".method public <init>()V\n");
		objectFile.append(".limit stack 1\n\n");
		objectFile.append("\taload_0\n");
		objectFile.append("\tinvokenonvirtual java/lang/Object/<init>()V\n");
		objectFile.append("\treturn\n");
		objectFile.append("\n");
		objectFile.append(".end method\n");
		objectFile.append("\n");
    }
    
    private void printMain(PrintWriter objectFile) throws FileNotFoundException {
    	SymTabEntry programId = symTabStack.getProgramId();
		objectFile.append(".method public static main([Ljava/lang/String;)V\n");
		objectFile.append(".limit stack  " + STACK_LIMIT + "\n");
		objectFile.append(".limit locals 10\n\n");
		objectFile.append("\t;References init:\n");
		objectFile.append("\tbipush 10\n");
		objectFile.append("\tanewarray wci/runtime/Referencer\n");
		objectFile.append("\tputstatic " + programId.getName() + "/_references [Lwci/runtime/Referencer;\n\n");
		
		ICodeNode rootNode = (ICodeNode) iCode.getRoot();
		StatementCodeGenerator gen = new StatementCodeGenerator(this);
		objectFile.append(gen.generate(rootNode).toString());
		
		objectFile.append("\treturn\n");
		objectFile.append("\n.end method\n");
    }
}
